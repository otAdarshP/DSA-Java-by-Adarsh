Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated
according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.


1. BRUTE FORCE: O(n^3)

public boolean isValidSudoku(char[][] board) {
    int n = 9;

    // skip those which do not need to be validated
    for (int i = 0; i < n;  i++){
        for (int j = 0; j  < n; j++){
            char num = board [i][j];
            if (num == '.'){
                continue;
            }
        }
    }

    // rows check for duplicates
    for (int col = 0; col > n; col ++){
        if (col != j && board[i][col] == num){
            return false;
        }
    }

    // cols check for duplicates
    for (int rows = 0; rows < n; rows++){
        if (row != i && board [row][j] == num){
            return false;
        }
    }

    // check within the boxes

    // finding the start of the required box
    int rowBox = i / 3 * 3;
    int colBox = j / 3 * 3;

    // define the boundaries of the box
    for (int r = rowBox; r < rowBox + 3; r++){
        for (int c = colBox; c < colBox + 3; c++){
            // to search within the box for duplicates
            if ((r != i || c != j) && board[r][c] == num){
                return false;
            }
        }
    }
    return true;
}


2. hashset constraints validation . TC: O(1)

public boolean isValidSudoku(char[][] board) {
    int n = 9;
    HashSet <Character> row = new HashSet[n];
    HashSet <Character> col = new HashSet[n];
    HashSet <Character> boxes = new HashSet[n];

    for (int i = 0; i <n; i++){
        row[i] = new HashSet<>();
        col[i] = new HashSet<>();
        boxes[i] = new HashSet<>();
    }

    // checking the whole sudoku:
    for (int r = 0; r < n; r++){
        for (int c = 0; c < n; c++){
            char num = board[r][c];
            if (num == '.'){
                continue;
            }


            // row check
            if (row[r].contains(num)){
            return false;
            }
            else{
                row[r].add(num);
            }

            // col check
            if (col[c].contains(num)){
                return false;
            }
            else{
                col[c].add(num);
            }

            // finding which box of the sudoku does the value exists in
            int boxIndex = r / 3 * 3 + c / 3;
            if (boxes[boxIndex].contains(num)){
                return false;
            }
            else{
                boxes[boxIndex].add(num);
            }
        }
    }
    return true;
}


3. Boolean arrays method. TC = O(1)

public boolean isValidSudoku(char[][] board){
    int n = 9;
    boolean [][] row = new boolean [n][n];
    boolean [][] col = new boolean [n][n];
    boolean [][] boxes = new boolean [n][n];

    // check through the whole box
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            char ch = board[i][j];
            if (ch == '.'){
                continue;
            }

            int num = ch - '1'; // shift 1-9 -> 0-8
            int boxIndex = i / 3 * 3 + j / 3;

            // if any of this is true, then the entry exists in the sudoku
            if (row[i][num] || col[j][num] || boxes [boxIndex][num]){
                return false; // invalid entries
            }

            // mark the numbers as seen
            row[i][num] = true;
            col[j][num] = true;
            boxes[boxIndex][num] = true;
        }
    }
    return true;
}

4. Bit masking. TC: O(1), but this is a concept used in Competitive Programming.
DON'T UNDERSTAND THE LOGIC, BUT THIS IS HOW THE CODE WORKS

public boolean isValidSudoku(char[][] board){

     int n = 9;
     int [] row = new int[n];
     int[] col = new int[n];
     int [] boxes = new int [n];

     for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            char ch = board[i][j];
            if (ch == '.'){
                continue;
            }

            int num = ch - '1';

            int mask = 1 << num;

            int boxIndex = (i / 3) * 3 + (j / 3);

            if ((row[i] & mask) > 0 || (col[j] & mask) > 0 || (boxes[boxIndex] & mask) > 0){
                return false;
            }

            row [i] |= mask;
            col[j] |= mask;
            boxes[boxIndex] |= mask;
        }
     }
     return true;
}