Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated
according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.


1. BRUTE FORCE: O(n^3)

public boolean isValidSudoku(char[][] board) {
    int n = 9;

    // skip those which do not need to be validated
    for (int i = 0; i < n;  i++){
        for (int j = 0; j  < n; j++){
            char num = board [i][j];
            if (num == '.'){
                continue;
            }
        }
    }

    // rows check for duplicates
    for (int col = 0; col > n; col ++){
        if (col != j && board[i][col] == num){
            return false;
        }
    }

    // cols check for duplicates
    for (int rows = 0; rows < n; rows++){
        if (row != i && board [row][j] == num){
            return false;
        }
    }

    // check within the boxes

    // finding the start of the required box
    int rowBox = i / 3 * 3;
    int colBox = j / 3 * 3;

    // define the boundaries of the box
    for (int r = rowBox; r < rowBox + 3; r++){
        for (int c = colBox; c < colBox + 3; c++){
            // to search within the box for duplicates
            if ((r != i || c != j) && board[r][c] == num){
                return false;
            }
        }
    }
    return true;
}


2. hashset constraints validation . TC: O(1)

public boolean isValidSudoku(char[][] board) {
    int n = 9;
    HashSet <Character> row = new HashSet[n];
    HashSet <Character> col = new HashSet[n];
    HashSet <Character> boxes = new HashSet[n];

    for (int i = 0; i <n; i++){
        row[i] = new HashSet<>();
        col[i] = new HashSet<>();
        boxes[i] = new HashSet<>();
    }

    // checking the whole sudoku:
    for (int r = 0; r < n; r++){
        for (int c = 0; c < n; c++){
            char num = board[r][c];
            if (num == '.'){
                continue;
            }


            // row check
            if (row[r].contains(num)){
            return false;
            }
            else{
                row[r].add(num);
            }

            // col check
            if (col[c].contains(num)){
                return false;
            }
            else{
                col[c].add(num);
            }

            // finding which box of the sudoku does the value exists in
            int boxIndex = r / 3 * 3 + c / 3;
            if (boxes[boxIndex].contains(num)){
                return false;
            }
            else{
                boxes[boxIndex].add(num);
            }
        }
    }
    return true;
}


3. 